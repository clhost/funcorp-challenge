[![Build Status](https://travis-ci.com/clhost/funcorp-challenge.svg?token=8Qu4bPcVDqaSCkhPsMBM&branch=release/1.0.x)](https://travis-ci.com/clhost/funcorp-challenge)

# Funcorp Challenge Task
Напишите приложение на Java или/и KotlIn, которое с максимальной скоростью распознает и соберёт все мемы на 
немецком языке и вернёт их в качестве ленты контента, сопровождаемого метаданными, отсортированной по времени 
публикации от более свежих к более старым.

Термин «мемы» мы трактуем широко: это могут быть тематические картинки, комиксы, забавные видео, рисунки, 
производные от аниме и манги и т.п.

Контент в приложении должен быть уникальным, то есть нужно отфильтровать дубликаты. 
Алгоритм любой, от хэш-суммы файла до нечёткого сравнения.

Настройка источников мемов должна быть достаточно гибкой, 
чтобы добавление новых можно было обеспечить редактированием конфигурационных файлов.

Предполагается, что лента отдаётся в REST-парадигме: endpoint GET /feed, 
возвращающий постраничный список контента для предпросмотра, и endpoint GET /feed/:contentID, 
возвращающий отдельные контенты с полными метаданными.

Приложение будет работать в Docker-контейнере, а значит в корне репозитория должен лежать Dockerfile и приложение должно 
запускаться по команде: docker run --rm -it $(docker build -q .)

Приложение должно соответствовать основным принципам 12-factor:
* Писать логи в STDOUT без промежуточной буферизации
* Конфигурироваться через environment-переменные
* Не хранить состояние
* Масштабироваться горизонтально

Под последним пунктом мы понимаем конфигурацию, когда приложение развёрнуто в кластере из нескольких хостов и запросы 
между ними распределяет балансировщик. Все хосты кластера получают одинаковый набор environment-переменных. 
Все нужные вашему приложению внешние сервисы (базы данных, кэши, объектные или файловые хранилища) также должны 
задаваться конфигурационными параметрами. Если что, то наш любимый стек — Redis, MongoDB и AWS S3.

Конкурсное задание должно сопровождаться файлом README с описанием сборки и запуска, 
пример конфигурации переменных среды можно положить рядом в файле .env.example

# Architecture
## Участвующие компоненты
1. **Minio** - как объектное неупорядоченное хранилище картинок (мемов)
2. **Consul** - как система, управляющая конфигурацией источников и как service discovery для обнаружения 
   компонентами ```App``` компоненты  ```tree```
3. **Postgres** - бд, хранящая персистентно мета-информацию для поиска в Minio и множество 
   перцептивных хешей для построения метрического дерева (VP-tree)
4. **VP-tree** - дерево для объектов метрического пространства, необходимое для быстрого обнаружения дубликатов мемов
5. **App** - само приложение, агрегирующее мемы с заданных источников и выдающее их в отсортированную ленту

## Алгоритмы
1. Динамическое распределение источников между нодами приложения - на старте в Consul KV выгружается в путь 
   ```example/source``` содержимое файла ```example-sources.json```, который имеет формат:
   ```
   [
     {
       "source": "vk",          // источник мемов
       "lang": "de",            // на каком языке мемы
       "type": "group",         // где искать мемы в заданном источнике "source"
       "subSource": "germameme" // конкретный источник мемов, имеющий тип "type"
     },
     {
       /.../
     }
   ]
    ```
   Распределение источников равномерное, можно добавлять/удалять источник/ноду, т.к. на старте работы воркера 
   изменения трекаются и нода пересчитывает свои источники согласно изменениям.
2. Поиск дубликатов - вычисление расстояния Хемминга между двумя перцептивными хешами двух сравниваемых мемов.
   Хранение в VP-tree выборки хешей (last N) для быстрой проверки, персист - в Postgres.
   
## Требования
Отдельная нода для расположения на ней Minio, Consul, Postgres и VP-tree. Для удобства всё завернуто в Docker. 
Репликации и прочие штуки опущены. 












duplicateThreshold должен задаваться 1 раз при запуске и больше не меняться
bitResolution должен задаваться 1 раз при запуске и больше не меняться